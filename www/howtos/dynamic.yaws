<erl>
  out(A) -> [{yssi, "../includes/config.yaws"}].
</erl>

<div class="text-right">
  <a href="#howto_overview">&#10143; Overview</a>
</div>
<br/>
<p class="text-justify">
  Yaws has very nice support for generating dynamic content on the fly. We use
  embedded Erlang code to generate the content. The Erlang code is separated
  from the HTML code by <code>&lt;erl&gt;</code> and <code>&lt;/erl&gt;</code>
  markers. For example:
</p>
<verbatim class="code html">
  <html>
    <h1>Foobar</h1>
    <erl>
      out(Arg) ->
          {html, "Funky Stuff"}.
    </erl>
    <h1>Baz</h1>
  </html>
</verbatim>
<br/>
<p class="text-justify">
  It is a very small example where we have a HTML document with embedded Erlang
  code. A file which contains embedded Erlang code must have the file suffix
  <code>.yaws</code>.
</p>
<br/>
<p class="text-justify">
  The embedded Erlang code can return the different values which will trigger
  the Yaws webserver to do different things. We list some of the simple return
  values here:
  <ul>
    <li>
      <p class="text-justify">
        <code>{html, DeepCharOrBinaryList}</code> Which will make the value of
        <code>DeepCharOrBinaryList</code> be substituted into the HTML document.
      </p>
    </li>
    <li>
      <p class="text-justify">
        <code>{ehtml, ErlangTermStructure}</code> It is often more convenient to
        return Erlang terms which are then transformed to HTML instead of
        returning plain HTML in string form using the <code>html</code> tag.
        Using the EHTML return value, we can return deep structured Erlang terms
        that correspond directly to HTML code. For example:
      </p>
      <verbatim class="code erlang">
  {table, [{bgcolor, "tan"}],
   {tr, [],
    [{td, [{width, "70%"}], {p, [{class, "foo"}], "Hi there"}}]}}
      </verbatim>
      <p class="text-justify">
        Corresponds to the following HTML code:
      </p>
      <verbatim class="code html">
  <table bgcolor="tan">
    <tr>
      <td width="70%">
        <p class="foo">Hi there</p>
      </td>
    </tr>
  </table>
      </verbatim>
      <br/>
    </li>
    <li>
      <p class="text-justify">
        <code>{header, Header}</code> If a <code>header</code> structure is
        returned, an additional header is inserted among the HTTP headers
        generated by Yaws. This is used to insert for example
        <code>Set-Cookie</code> headers. The <code>Header</code> variable
        must not be newline terminated.
      </p>
    </li>
    <li>
      <p class="text-justify">
        <code>{allheaders, Header}</code> If an <code>allheaders</code>
        structure is returned, all previous headers that have been generated,
        including those default headers generated by Yaws itself are erased, and
        replaced by the headers in <code>Headers</code> which must be a list of
        <code>{header, Str}</code> tuples. The <code>Str</code> must not be
        newline terminated.
      </p>
    </li>
    <li>
      <p class="text-justify">
        <code>{status, StatusCodeInt}</code> Is used to force Yaws to return a
        different status code than the default 200 code.
      </p>
    </li>
    <li>
      <p class="text-justify"><code>ok</code> Do nothing.</p>
    </li>
    <li>
      <p class="text-justify">
        <code>{content, MimeType, Content}</code> Sets the mime type, that is
        the <code>Content-Type</code> header to be <code>MimeType</code>. The
        default value is of course <code>"text/html"</code>, but applications
        that generate i.e wml or pdf, must set the <code>Content-Type</code>.
        A pdf generating application can for example return the tuple
        <code>{content, "application/pdf", PdfContentData}</code>.
      </p>
    </li>
    <li>
      <p class="text-justify">
        <code>{redirect, URL}</code> A redirect is issued to the location in
        <code>URL</code>.
      </p>
    </li>
    <li>
      <p class="text-justify">
        <code>{redirect_local, Path}</code> A redirect is issued to the local
        server using the same method (HTTP or HTTPS) as the incoming request and
        the path part of the location header to the value in <code>Path</code>.
      </p>
    </li>
    <li>
      <p class="text-justify">
        <code>{'EXIT', normal}</code> Which will terminate the client connection
        in an uncontrolled way.
      </p>
    </li>
    <li>
      <p class="text-justify">
        <code>{ssi, File, Delimiter, Bindings}</code> Using this construct, we
        can deep inside a EHTML structure, return Server Side Include (SSI)
        content from a file. This construct is further described in
        <a href="#howto_ssi">ssi.yaws</a>.
      </p>
    </li>
  </ul>
</p>
<br/>
<p class="text-justify">
  The embedded Erlang code can also return a list of the above values. For
  example the following value:
</p>
<verbatim class="code erlang">
  [{status, 303},
   {allheaders,
       [{header, ["Location: ","http://www.funky.org/"]},
        {header, ["Set-Cookie: ","namn=ruler;"]}
       ]},
   {html,"<html>Redirected to funky.org </html>"}]
</verbatim>
<br/>
<p class="text-justify">
  can be returned if we want to issue a redirect and set a cookie at the same
  time. All possible return values from the <code>out/1</code> function are
  documented in the man page for
  <a href="documentation.yaws?manpage=yaws_api">yaws_api (5)</a>.
</p>
<p class="text-justify">
  It can also be instructive to look at the actual source for the pages we are
  viewing at this very moment. Here are some of them:
  <ul>
    <li>
      <p class="text-justify">
        <a href="index.yaws">The top page</a> and then the corresponding
        <a class="btn-link"
           onclick="load_modal('Code', 'code.yaws?file=%%webroot%%/index.yaws&type=html');"
           data-toggle="modal" data-target="#yawsModal">source</a>.
      </p>
    </li>
    <li>
      <p class="text-justify">
        <a href="#howto_dynamic">The current page</a> and then the corresponding
        <a class="btn-link"
           onclick="load_modal('Code', 'code.yaws?file=%%webroot%%/howtos/dynamic.yaws&type=html');"
           data-toggle="modal" data-target="#yawsModal">source</a>.
      </p>
    </li>
  </ul>
</p>
<br/>
<h2>The argument</h2>
<p class="text-justify">
  The <code>out/1</code> function is supplied with a record argument. The
  definition of that record is automatically included in the embedded erlang
  code and the record definition is:
</p>
<verbatim class="code erlang">
    -record(arg, {
          clisock,        % the socket leading to the peer client
          client_ip_port, % {ClientIp, ClientPort} tuple
          headers,        % headers
          req,            % request (possibly rewritten)
          orig_req,       % original request
          clidata,        % The client data (as a binary in POST requests)
          server_path,    % The normalized server path
                          % (pre-querystring part of URI)
          querydata,      % For URIs of the form ...?querydata
                          %  equiv of cgi QUERY_STRING
          appmoddata,     % (deprecated - use pathinfo instead) the remainder
                          % of the path leading up to the query
          docroot,        % Physical base location of data for this request
          docroot_mount,  % virtual directory e.g /myapp/ that the docroot
                          %  refers to.
          fullpath,       % full deep path to yaws file
          cont,           % Continuation for chunked multipart uploads
          state,          % State for use by users of the out/1 callback
          pid,            % pid of the yaws worker process
          opaque,         % useful to pass static data
          appmod_prepath, % (deprecated - use prepath instead) path in front
                          %  of: <appmod><appmoddata>
          prepath,        % Path prior to 'dynamic' segment of URI.
                          %  ie http://some.host/<prepath>/<script-point>/d/e
                          % where <script-point> is an appmod mount point,
                          % or .yaws,.php,.cgi,.fcgi etc script file.
          pathinfo        % Set to '/d/e' when calling c.yaws for the request
                          % http://some.host/a/b/c.yaws/d/e
                          %  equiv of cgi PATH_INFO
         }).
</verbatim>
<br/>
<p class="text-justify">
  And some of the refered records are defined as:
</p>
<verbatim class="code erlang">
  -record(http_request, {method, path, version}).

  -record(headers, {
          connection,
          accept,
          host,
          if_modified_since,
          if_match,
          if_none_match,
          if_range,
          if_unmodified_since,
          range,
          referer,
          user_agent,
          accept_ranges,
          cookie = [],
          keep_alive,
          location,
          content_length,
          content_type,
          content_encoding,
          authorization,
          transfer_encoding,
          x_forwarded_for,
          other = []   % misc other headers
         }).
</verbatim>
<br/>
<p class="text-justify">
  Each chunk of Erlang code will be compiled into a separate module. The
  module names are automatically generated. If we have functions inside the
  Erlang chunks that we want to call from other chunks or modules, it is
  possible to explicitly name the modue that will be used as in:
</p>
<verbatim class="code erlang">
  <erl module="foobar">
    -export([func/1]).

    out(A) ->
        io:format("This is the foobar module",[]).

    func() ->
        i_am_exported_from_foobar.
  </erl>
</verbatim>
