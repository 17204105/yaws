<erl>
-include_lib("kernel/include/file.hrl").


-record(upload, {fd,
                 filename,
                 content_type,
                 disk_file,
                 last}).

out(A) when A#arg.state == undefined ->
    State = #upload{},
    case multipart(A, State) of
        {ok, NewState}  -> success(NewState);
        {error, Reason} -> failure(Reason);
        GetMore         -> GetMore
    end;
out(A) ->
    case multipart(A, A#arg.state) of
        {ok, NewState}  -> success(NewState);
        {error, Reason} -> failure(Reason);
        GetMore         -> GetMore
    end.

success(State) ->
    {ok, FI} = file:read_file_info(State#upload.disk_file),
    Result   = "File successfully uploaded.",
    Fname    = State#upload.filename,
    CT       = State#upload.content_type,
    Sz       = case FI#file_info.size of
                   I when I >= 1048576 -> f("~.3f MB~n", [I/1048576]);
                   I when I >= 1024    -> f("~.3f KB~n", [I/1024]);
                   I                   -> f("~b B~n", [I])
               end,
    file:delete(State#upload.disk_file),
    {ehtml,
     [{h2, [], Result},
      {p, [], {ul, [], [{li, [], f("File name: ~s", [Fname])},
                        {li, [], f("Content-Type: ~s", [CT])},
                        {li, [], f("Size: ~s", [Sz])}]}}]}.


failure(Reason) ->
    Error = "An error occurred during the file upload.",
    {ehtml, [{h2, [], Error},
             {p, [], Reason}]}.

multipart(A, State) ->
    Parse = yaws_api:parse_multipart_post(A),
    case Parse of
        {cont, Cont, Res} ->
            case addFileChunk(A, Res, State) of
                {done,  NewState} -> {ok, NewState};
                {cont,  NewState} -> {get_more, Cont, NewState};
                {error, Reason}   -> {error, Reason}
            end;
        {result, Res} ->
            case addFileChunk(A, Res, State#upload{last=true}) of
                {done,  NewState} -> {ok, NewState};
                {cont,  _}        -> {error, "unknown error"};
                {error, Reason}   -> {error, Reason}
            end;
        {error, Reason} ->
            {error, f("parsing error: ~p", [Reason])}
    end.

addFileChunk(A, [{part_body, Data}|Res], State) ->
    addFileChunk(A, [{body, Data}|Res], State);
addFileChunk(_A, [], State) when State#upload.last==true,
                                 State#upload.filename /= undefined,
                                 State#upload.fd /= undefined ->
    file:close(State#upload.fd),
    {done, State#upload{fd=undefined}};
addFileChunk(A, [], State) when State#upload.last==true ->
    {error, "unknown error"};
addFileChunk(_A, [], State) ->
    {cont, State};
addFileChunk(A, [{head, {_Name, Opts}}|Res], State ) ->
    case lists:keyfind("filename", 1, Opts) of
        {_, []} ->
            {error, "No filename uploaded"};
        {_, Fname0} ->
            CType = case lists:keyfind(content_type, 1, Opts) of
                        {_, CT}   -> CT;
                        undefined -> "unknown"
                    end,

            %% we must not put the file in the docroot, it may execute uploade
            %% code if the file is a .yaws file !!!!!
            file:make_dir(yaws:tmpdir()),
            Fname = yaws_api:sanitize_file_name(basename(Fname0)),
            File = yaws:tmpdir() ++ "/" ++ Fname,
            case file:open(File, [write]) of
                {ok, Fd} ->
                    S2 = State#upload{fd           = Fd,
                                      filename     = Fname0,
                                      content_type = CType,
                                      disk_file    = File},
                    addFileChunk(A, Res, S2);
                {error, Reason} ->
                    {error, f("Cannot open file: ~p", [Reason])}
            end;
        false ->
            addFileChunk(A,Res,State)
    end;
addFileChunk(A, [{body, Data}|Res], State)
  when State#upload.filename /= undefined ->
    case file:write(State#upload.fd, Data) of
        ok ->
            addFileChunk(A, Res, State);
        {error, Reason} ->
            file:close(State#upload.fd),
            file:delete(State#upload.disk_file),
            {error, f("Cannot write file: ~p", [Reason])}
    end.


basename(FilePath) ->
    case string:rchr(FilePath, $\\) of
        0 -> %% probably not a DOS name
            filename:basename(FilePath);
        N -> %% probably a DOS name, remove everything after last \
            basename(string:substr(FilePath, N+1))
    end.
</erl>
